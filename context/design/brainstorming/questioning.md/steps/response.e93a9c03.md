---
timestamp: 'Mon Oct 20 2025 23:37:42 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251020_233742.f97447c7.md]]'
content_id: e93a9c034fdb5ecd5034500c0e23409363d8a7bec18ac68cf2c3f1e34e3101ad
---

# response:

To transition the `ViewerConcept` from using a CSV file for data storage to a MongoDB database, we'll need to make several modifications. This involves replacing file system operations with database interactions, and updating the data loading and saving mechanisms.

This modification assumes you have a separate `src/database.ts` file that handles the MongoDB connection and provides an interface for interacting with your `items` collection.

## Assumed `src/database.ts`

First, let's define the `src/database.ts` file that `ViewerConcept.ts` will rely on. This file will manage the MongoDB connection and provide utility functions.

```typescript
// file: src/database.ts
import { MongoClient, Db, Collection, ObjectId } from "mongodb";

// Replace with your MongoDB connection string
const MONGODB_URI = process.env.MONGODB_URI || "mongodb://localhost:27017/inventorydb";
const DB_NAME = "inventorydb";

let client: MongoClient;
let db: Db;

// Interface for the MongoDB document. _id is optional as it's generated by MongoDB.
export interface InventoryItemDocument {
  _id?: ObjectId;
  itemName: string;
  lastCheckout: Date | null;
  available: boolean;
  lastKerb: string;
  categories: string[];
  tags: string[];
}

/**
 * Connects to the MongoDB database.
 * If already connected, returns the existing database instance.
 */
export async function connectDB(): Promise<Db> {
  if (db && client && client.topology.isConnected()) { // Check connection status
    return db;
  }
  try {
    client = new MongoClient(MONGODB_URI);
    await client.connect();
    db = client.db(DB_NAME);
    console.log("Connected to MongoDB successfully!");
    return db;
  } catch (error) {
    console.error("Failed to connect to MongoDB:", error);
    throw error;
  }
}

/**
 * Returns the 'items' collection from the connected database.
 * Throws an error if the database is not connected.
 */
export function getItemsCollection(): Collection<InventoryItemDocument> {
  if (!db) {
    throw new Error("Database not connected. Call connectDB() first.");
  }
  return db.collection<InventoryItemDocument>("items");
}

/**
 * Disconnects from the MongoDB database.
 */
export async function disconnectDB(): Promise<void> {
  if (client) {
    await client.close();
    console.log("Disconnected from MongoDB.");
  }
}
```

## Modified `src/concepts/Viewer/ViewerConcept.ts`

Here are the changes to `ViewerConcept.ts`:

1. **Imports**: Remove `node:fs` and `node:path`. Add imports for `connectDB`, `getItemsCollection`, and `InventoryItemDocument` from `../../database.ts`.
2. **`csvPath`**: Remove the `csvPath` property from the class.
3. **`loadItems()`**:
   * Connect to MongoDB using `connectDB()`.
   * Retrieve the `items` collection using `getItemsCollection()`.
   * Fetch all documents from the collection.
   * Map the `InventoryItemDocument` objects from the database to the `Item` interface used in memory.
4. **`saveItems()`**:
   * Connect to MongoDB.
   * Retrieve the `items` collection.
   * **Crucially**: To mimic the "overwrite CSV" behavior, it first deletes all existing documents in the collection (`deleteMany({})`) and then inserts all the current `Item` objects from `this.items` into the collection. Note that `_id` is omitted for insertion, allowing MongoDB to generate new `_id`s.
5. **Helper Methods**: Remove `parseCsvLine`, `escapeCsv`, and `formatDate` as they are no longer relevant for CSV handling.
6. **`createViewerFromCsv()`**: Rename `createViewerFromCsv` to `createViewerFromDB` and update its logic to use the database.

```typescript
// file: src/concepts/Viewer/ViewerConcept.ts
import { promises as fs } from "node:fs"; // REMOVE THIS
import * as path from "node:path"; // REMOVE THIS
import { connectDB, getItemsCollection, InventoryItemDocument } from "../../database.ts"; // ADD THIS
import { GeminiLLM } from "../../gemini-llm.ts";

export interface Item {
  itemName: string;
  lastCheckout: Date | null;
  available: boolean;
  lastKerb: string;
  categories: string[];
  tags: string[];
}

export default class ViewerConcept {
  private items: Item[] = [];
  // private csvPath: string; // REMOVED: No longer using CSV

  constructor() {
    console.log("Creating a new Viewer constructor!");
    // this.csvPath = "src/utils/inventory.csv"; // REMOVED
  }

  /** Load items from MongoDB into memory */
  async loadItems(): Promise<void> {
    await connectDB(); // Ensure connection to MongoDB
    const collection = getItemsCollection(); // Get the 'items' collection

    const dbItems: InventoryItemDocument[] = await collection.find({}).toArray(); // Fetch all documents

    // Map database documents to in-memory Item objects
    this.items = dbItems.map((doc) => ({
      itemName: doc.itemName,
      lastCheckout: doc.lastCheckout,
      available: doc.available,
      lastKerb: doc.lastKerb,
      categories: doc.categories,
      tags: doc.tags,
      // _id from MongoDB document is not stored in the Item interface,
      // as itemName is treated as the primary conceptual identifier and saveItems performs a full overwrite.
    }));
    console.log(`Loaded ${this.items.length} items from MongoDB.`);
  }

  /** Persist in-memory items back to MongoDB (overwrites the entire 'items' collection) */
  async saveItems(): Promise<void> {
    await connectDB(); // Ensure connection to MongoDB
    const collection = getItemsCollection(); // Get the 'items' collection

    // To mirror the CSV overwrite behavior, first clear the collection
    await collection.deleteMany({});
    console.log("Cleared existing items in MongoDB.");

    // Convert in-memory Item objects to database documents (excluding _id for new inserts)
    const docsToInsert: Omit<InventoryItemDocument, "_id">[] = this.items.map(
      (item) => ({
        itemName: item.itemName,
        lastCheckout: item.lastCheckout,
        available: item.available,
        lastKerb: item.lastKerb,
        categories: item.categories,
        tags: item.tags,
      }),
    );

    // Insert all current items into the collection
    if (docsToInsert.length > 0) {
      await collection.insertMany(docsToInsert);
      console.log(`Saved ${docsToInsert.length} items to MongoDB.`);
    } else {
      console.log("No items to save.");
    }
  }

  /*=============== Query methods (remain largely the same, operating on this.items) ===============*/
  viewAvailable(): Item[] {
    return this.items.filter((i) => i.available);
  }

  viewItem(itemName: string): Item {
    const it = this.items.find((i) =>
      i.itemName.toLowerCase() === itemName.toLowerCase()
    );
    if (!it) throw new Error(`Item not found: ${itemName}`);
    return it;
  }

  viewCategory(category: string): Item[] {
    return this.items.filter((i) =>
      i.categories.some((c) => c.toLowerCase() === category.toLowerCase())
    );
  }

  viewTag(tag: string): Item[] {
    return this.items.filter((i) =>
      i.tags.some((t) => t.toLowerCase() === tag.toLowerCase())
    );
  }

  viewLastCheckedoutDate(itemName: string): Date {
    const it = this.viewItem(itemName);
    if (!it.lastCheckout) {
      throw new Error(`No lastCheckout recorded for ${itemName}`);
    }
    // return date-only (zero time)
    return new Date(it.lastCheckout.toISOString().slice(0, 10));
  }

  viewLastCheckedoutFull(itemName: string): Date {
    const it = this.viewItem(itemName);
    if (!it.lastCheckout) {
      throw new Error(`No lastCheckout recorded for ${itemName}`);
    }
    return new Date(it.lastCheckout); // full Date object
  }

  /*=============== AI-augmented methods (remain largely the same) ===============*/
  async viewAdjacent(itemName: string, llm: GeminiLLM): Promise<Item[]> {
    const it = this.items.find((i) =>
      i.itemName.toLowerCase() === itemName.toLowerCase()
    );
    if (!it) throw new Error(`Item not found: ${itemName}`);

    const prompt = this.createAdjacentPrompt(it);
    const text = await llm.executeLLM(prompt);
    const names = this.extractNameListFromLLM(text);
    return this.items.filter((i) => names.includes(i.itemName));
  }

  async viewAutocomplete(prefix: string, llm: GeminiLLM): Promise<Item[]> {
    const prompt = this.createAutocompletePrompt(prefix);
    const text = await llm.executeLLM(prompt);
    const names = this.extractNameListFromLLM(text);
    // match with available items by exact name
    return this.items.filter((i) => names.includes(i.itemName));
  }

  async recommendItems(
    interests: string,
    llm: GeminiLLM,
  ): Promise<{ item: Item; suggestion: string }[]> {
    const prompt = this.createRecommendPrompt(interests);
    const text = await llm.executeLLM(prompt);
    // Expect JSON: [{"itemName":"...","suggestion":"..."}, ...]
    const json = this.extractJson(text);
    if (!Array.isArray(json)) {
      throw new Error("LLM recommendItems returned invalid format");
    }
    const results: { item: Item; suggestion: string }[] = [];
    for (const entry of json) {
      if (!entry || typeof entry.itemName !== "string") continue;
      const item = this.items.find((i) => i.itemName === entry.itemName);
      if (item) {
        results.push({ item, suggestion: String(entry.suggestion ?? "") });
      }
    }
    return results;
  }

  /*=============== Helpers ===============*/
  // REMOVED: parseCsvLine - no longer needed with database storage
  // REMOVED: escapeCsv - no longer needed with database storage
  // REMOVED: formatDate - no longer needed for persistence; date handling in viewLastCheckedoutDate is fine.

  private createAdjacentPrompt(target: Item): string {
    const inventorySummary = this.items.map((i) =>
      `${i.itemName} | categories:${i.categories.join(";")!} | tags:${
        i.tags.join(";")
      }`
    ).join("\n");
    return `You are an assistant that, given a target inventory item, returns a JSON array of itemName strings representing the most similar items from the inventory.
Target item:\n${target.itemName} | categories:${
      target.categories.join(";")
    } | tags:${target.tags.join(";")}

INVENTORY:\n${inventorySummary}

Return exactly a JSON array of itemName strings, in order of similarity.`;
  }

  private createAutocompletePrompt(prefix: string): string {
    const names = this.items.map((i) => i.itemName).join("\n");
    return `You are an assistant that returns up to 8 item names from the inventory that best match the user's partial input. User input: "${prefix}"\nINVENTORY NAMES:\n${names}\nReturn exactly a JSON array of matching itemName strings.`;
  }

  private createRecommendPrompt(interests: string): string {
    // Provide limited inventory context + interests, request itemName + suggestion
    const shortList = this.items.slice(0, 60).map((i) => ({
      itemName: i.itemName,
      tags: i.tags,
      categories: i.categories,
    }));
    return `You are an assistant that recommends inventory items for a user based on their interests. INTERESTS: ${interests}\n
INVENTORY SAMPLE:\n${JSON.stringify(shortList, null, 2)}\n
Return a JSON array of objects with fields: {"itemName": string, "suggestion": string} where suggestion is a one-sentence activity idea using the item that matches the interests. Return only JSON.`;
  }

  private extractNameListFromLLM(text: string): string[] {
    const json = this.extractJson(text);
    if (Array.isArray(json)) return json.filter((v) => typeof v === "string");
    return [];
  }

  private extractJson(text: string): any {
    const match = text.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
    if (!match) throw new Error("No JSON found in LLM response");
    try {
      return JSON.parse(match[0]);
    } catch (e) {
      throw new Error("Failed to parse JSON from LLM response");
    }
  }
}

// Export a small helper for quick CLI testing (not required by the spec)
export async function createViewerFromDB(): Promise<ViewerConcept> { // RENAMED and MODIFIED
  const v = new ViewerConcept();
  await v.loadItems(); // Load items from DB
  return v;
}
```
